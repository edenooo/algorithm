<snippet>
	<content><![CDATA[
/*
	sa 인덱스 범위 [1, |s|] 값 범위 [0,|s|-1]
	rank 인덱스 범위 [0, |s|-1] 값 범위 [1,|s|]
	lcp 인덱스 범위 [2, |s|]
*/
template<class Str>
struct suffix_array {
	int n;
	vector<int> sa, rank, lcp;
	suffix_array(const Str &s, int lim = 256) : n(int(s.size()) + 1), sa(n), rank(n), lcp(n) {
		int n = int(s.size()) + 1, k = 0, a, b;
		vector<int> x(s.begin(), s.end() + 1), y(n), ws(max(n, lim));
		iota(sa.begin(), sa.end(), 0);
		for (int j = 0, p = 0; p < n; j = max(1, j * 2), lim = p) {
			p = j, iota(y.begin(), y.end(), n - j);
			for (int i = 0; i < n; ++i) if (sa[i] >= j) y[p++] = sa[i] - j;
			fill(ws.begin(), ws.end(), 0);
			for (int i = 0; i < n; ++i) ws[x[i]] ++;
			for (int i = 1; i < lim; ++i) ws[i] += ws[i - 1];
			for (int i = n; i--; ) sa[--ws[x[y[i]]]] = y[i];
			swap(x, y), p = 1, x[sa[0]] = 0;
			for (int i = 1; i < n; ++i) {
				a = sa[i - 1], b = sa[i];
				x[b] = (y[a] == y[b] && y[a + j] == y[b + j]) ? p - 1 : p++;
			}
		}
		for (int i = 1; i < n; ++i) rank[sa[i]] = i;
		for (int i = 0, j; i < n - 1; lcp[rank[i++]] = k) for (k && k--, j = sa[rank[i] - 1]; s[i + k] == s[j + k]; k++);
	}
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>__suffix_array</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
